/* 
 * Bitcoin cryptography library
 * Copyright (c) Project Nayuki
 * 
 * https://www.nayuki.io/page/bitcoin-cryptography-library
 * https://github.com/nayuki/Bitcoin-Cryptography-Library
 */

package io.nayuki.bitcoin.crypto;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import java.math.BigInteger;
import java.util.Random;
import org.junit.Test;


/**
 * Tests the functions of the Int256Math class.
 */
public final class Int256MathTest {
	
	@Test public void testComparison() {
		String[][] cases = {
			{"0000000000000000000000000000000000000000000000000000000000000000", "0000000000000000000000000000000000000000000000000000000000000000"},
			{"0000000000000000000000000000000000000000000000000000000000000000", "0000000000000000000000000000000000000000000000000000000000000001"},
			{"0000000000000000000000000000000000000000000000000000000000000080", "0000000000000000000000000000000000000000000000000000000000000000"},
			{"FF00000000000000000000000000000000000000000000000000000000000000", "0000000000000000000000000000000000000000000000000000000000000000"},
			{"F000000000000000000000000000000000000000000000000000000000000000", "0000000000000000000000000000000000000000000000000000000000000000"},
			{"0123400000000000000000000000000000000000000000000000000000000000", "0123400000000000000000000000000000000000000000000000000000000000"},
			{"0000000000000000000000000000000000000000000000000000000000000000", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F"},
			{"00000000000000000000000000000000000000000000000000000000000000FF", "FF00000000000000000000000000000000000000000000000000000000000000"},
		};
		for (int i = 0; i < 30000; i++) {
			String s = i < cases.length ? cases[i][0] : randomInt256Str();
			String t = i < cases.length ? cases[i][1] : randomInt256Str();
			TestArray arr = new TestArray(s, t, 0);
			BigInteger a = toBigInt(s);
			BigInteger b = toBigInt(t);
			int cmp = a.compareTo(b);
			assertEquals(cmp == 0 ? 1 : 0, Int256Math.equalTo (arr.val, arr.xOff, arr.yOff));
			assertEquals(cmp <  0 ? 1 : 0, Int256Math.lessThan(arr.val, arr.xOff, arr.yOff));
			assertEquals(cmp >  0 ? 1 : 0, Int256Math.lessThan(arr.val, arr.yOff, arr.xOff));
			arr.checkClobber();
		}
	}
	
	
	@Test public void testUintAdd() {
		String[][] cases = {
			{"0000000000000000000000000000000000000000000000000000000000000000", "0000000000000000000000000000000000000000000000000000000000000000"},
			{"0000000000000000000000000000000000000000000000000000000080000000", "0000000000000000000000000000000000000000000000000000000080000000"},
			{"000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFF", "0000000000000000000000000000000000000000000000000000000000000001"},
			{"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2E", "0000000000000000000000000000000000000000000000000000000000000001"},
			{"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", "0000000000000000000000000000000000000000000000000000000000000001"},
			{"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"},
			{"FF00000000000000000000000000000000000000000000000000000000000000", "FF00000000000000000000000000000000000000000000000000000000000000"},
		};
		for (int i = 0; i < 30000; i++) {
			String s = i < cases.length ? cases[i][0] : randomInt256Str();
			String t = i < cases.length ? cases[i][1] : randomInt256Str();
			TestArray arr = new TestArray(s, t, 0);
			BigInteger a = toBigInt(s);
			BigInteger b = toBigInt(t);
			BigInteger c = a.add(b);
			if (arr.zOff != arr.xOff && arr.zOff != arr.yOff) {
				assertEquals(0, Int256Math.uintAdd(arr.val, arr.xOff, arr.yOff, 0, arr.zOff));
				assertEqualsBigInt256(a, arr.val, arr.zOff);
			}
			assertEquals(c.shiftRight(256).intValue(), Int256Math.uintAdd(arr.val, arr.xOff, arr.yOff, 1, arr.zOff));
			assertEqualsBigInt256(c, arr.val, arr.zOff);
			arr.checkClobber();
		}
	}
	
	
	@Test public void testUintSubtract() {
		String[][] cases = {
			{"0000000000000000000000000000000000000000000000000000000000000000", "0000000000000000000000000000000000000000000000000000000000000000"},
			{"0000000000000000000000000000000000000000000000000000000000000003", "0000000000000000000000000000000000000000000000000000000000000002"},
			{"0000000000000000000000000000000000000000000000000000000000000000", "0000000000000000000000000000000000000000000000000000000000000001"},
			{"0000000000000000000000000000000000000000000000000000000000000000", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"},
		};
		for (int i = 0; i < 30000; i++) {
			String s = i < cases.length ? cases[i][0] : randomInt256Str();
			String t = i < cases.length ? cases[i][1] : randomInt256Str();
			TestArray arr = new TestArray(s, t, 0);
			BigInteger a = toBigInt(s);
			BigInteger b = toBigInt(t);
			BigInteger c = a.subtract(b);
			if (arr.zOff != arr.xOff && arr.zOff != arr.yOff) {
				assertEquals(0, Int256Math.uintSubtract(arr.val, arr.xOff, arr.yOff, 0, arr.zOff));
				assertEqualsBigInt256(a, arr.val, arr.zOff);
			}
			assertEquals(-c.shiftRight(256).intValue(), Int256Math.uintSubtract(arr.val, arr.xOff, arr.yOff, 1, arr.zOff));
			assertEqualsBigInt256(c, arr.val, arr.zOff);
			arr.checkClobber();
		}
	}
	
	
	@Test public void testUintShiftLeft1() {
		String[] cases = {
			"0000000000000000000000000000000000000000000000000000000000000000",
			"0000000000000000000000000000000000000000000000000000000000000001",
			"0000000000000000000000000000000000000000000000000000000080000000",
			"00000000000000000000000000000000000000000000000000000000FFFFFFFF",
			"000ABCDEF0000000000000000000000000000000000000000000000000000000",
			"8000000000000000000000000000000000000000000000000000000000000000",
			"FFFF000000000000000000000000000000000000000000000000000000000000",
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
		};
		for (int i = 0; i < 100000; i++) {
			String s = i < cases.length ? cases[i] : randomInt256Str();
			TestArray arr = new TestArray(s, null, 0);
			BigInteger a = toBigInt(s);
			BigInteger b = a.shiftLeft(1);
			assertEquals(a.testBit(255) ? 1 : 0, Int256Math.uintShiftLeft1(arr.val, arr.xOff, arr.zOff));
			assertEqualsBigInt256(b, arr.val, arr.zOff);
			arr.checkClobber();
		}
	}
	
	
	@Test public void testUintShiftRight1() {
		String[] cases = {
			"0000000000000000000000000000000000000000000000000000000000000000",
			"0000000000000000000000000000000000000000000000000000000000000001",
			"0000000000000000000000000000000000000000000000000000000080000000",
			"00000000000000000000000000000000000000000000000000000000FFFFFFFF",
			"000ABCDEF0000000000000000000000000000000000000000000000000000000",
			"8000000000000000000000000000000000000000000000000000000000000000",
			"FFFF000000000000000000000000000000000000000000000000000000000000",
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
		};
		for (int i = 0; i < 100000; i++) {
			String s = i < cases.length ? cases[i] : randomInt256Str();
			TestArray arr = new TestArray(s, null, 0);
			BigInteger a = toBigInt(s);
			BigInteger b = a.shiftRight(1);
			if (arr.zOff != arr.xOff) {
				Int256Math.uintShiftRight1(arr.val, arr.xOff, 0, arr.zOff);
				assertEqualsBigInt256(a, arr.val, arr.zOff);
			}
			Int256Math.uintShiftRight1(arr.val, arr.xOff, 1, arr.zOff);
			assertEqualsBigInt256(b, arr.val, arr.zOff);
			arr.checkClobber();
		}
	}
	
	
	@Test public void testReciprocalRandomly() {
		for (int i = 0; i < 300; i++) {
			BigInteger mod;  // Choose an odd number at least 128 bits long
			do mod = new BigInteger(192 + rand.nextInt(65), rand);
			while (!mod.testBit(0) || mod.bitLength() < 128);
			
			for (int j = 0; j < 30; j++) {
				BigInteger a;  // Choose 'a' in [0, mod) that is coprime to mod
				do a = new BigInteger(mod.bitLength(), rand);
				while (!a.gcd(mod).equals(BigInteger.ONE));
				a = a.mod(mod);
				
				TestArray arr = new TestArray(String.format("%064x", a), String.format("%064x", mod), Int256Math.RECIPROCAL_TEMP_WORDS);
				Int256Math.reciprocal(arr.val, arr.xOff, arr.yOff, arr.zOff, arr.tempOff);
				BigInteger b = a.modInverse(mod);
				assertEqualsBigInt256(b, arr.val, arr.zOff);
				arr.checkClobber();
			}
		}
	}
	
	
	@Test public void testFieldAdd() {
		String[][] cases = {
			{"0000000000000000000000000000000000000000000000000000000000000000", "0000000000000000000000000000000000000000000000000000000000000000"},
			{"0000000000000000000000000000000000000000000000000000000080000000", "0000000000000000000000000000000000000000000000000000000080000000"},
			{"000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFF", "0000000000000000000000000000000000000000000000000000000000000001"},
			{"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2E", "0000000000000000000000000000000000000000000000000000000000000001"},
			{"0000000000000000000000000000000000000000000000000000000000000001", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2E"},
			{"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2E", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2E"},
			{"FF00000000000000000000000000000000000000000000000000000000000000", "FF00000000000000000000000000000000000000000000000000000000000000"},
			{"CF82A6E670C187AF1855BFD6A02F676D58B2659A6010EDA5B1ADA5662135EA37", "3130EC4C765E299FE200CD62BF4439F061440B57751B104BF14552A553064508"},
			{"F93CAB87674D5FEA845300E8BC63C9D313585200F2DA0E9B955CD07FAFB46787", "42207C06D78BD8D62C57746D35D0427AD9EDAA7D8AA2BFD39144167418E44DC4"},
			{"A30910E72FD6AC01A3EF74124085ECDA6713B0E4D7E840C4890ECD272C83A394", "71AB910A371A0D15370C19D5B1562EDB339C66C9DBC72E4194D5B3361F9208B6"},
		};
		for (int i = 0; i < 30000; i++) {
			String s = i < cases.length ? cases[i][0] : randomFieldIntStr();
			String t = i < cases.length ? cases[i][1] : randomFieldIntStr();
			TestArray arr = new TestArray(s, t, Int256Math.FIELD_ADD_TEMP_WORDS);
			BigInteger a = toBigInt(s);
			BigInteger b = toBigInt(t);
			BigInteger c = a.add(b).mod(FIELD_MODULUS);
			Int256Math.fieldAdd(arr.val, arr.xOff, arr.yOff, arr.zOff, arr.tempOff);
			assertEqualsBigInt256(c, arr.val, arr.zOff);
			arr.checkClobber();
		}
	}
	
	
	@Test public void testFieldSubtract() {
		String[][] cases = {
			{"0000000000000000000000000000000000000000000000000000000000000000", "0000000000000000000000000000000000000000000000000000000000000000"},
			{"0000000000000000000000000000000000000000000000000000000000000003", "0000000000000000000000000000000000000000000000000000000000000002"},
			{"0000000000000000000000000000000000000000000000000000000000000000", "0000000000000000000000000000000000000000000000000000000000000001"},
			{"0000000000000000000000000000000000000000000000000000000000000000", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2E"},
			{"0000000000000000000000000000000000000000000000000000000000000000", "0FFF000000000000000000050000000400003000000000000200100000000000"},
			{"484786B41F8CC919C7B47E08B918E13BCADF20777224E3B7C7334EDF6E98CBBE", "57F3E075C0014548EB29756F8C4394D1541112662C298F8BAC5211F7FC9D8930"},
			{"69A1B6279F3CF9E29D9D46C32AEBAB2694A25DFE291A2B6F7A8116727B811705", "290113FE9D369FE41F1CB33B29AD34666744A06A310A30A98B8D631A36133A4B"},
			{"E5E4684E5EDDA9EEFA6D4CBF84089280750391E9E68B95C84C671B07D2AF9081", "686058D3961A761D9A60E2810487BDE706BB5DF21005E4EC1C2B68ECC7F6E241"},
		};
		for (int i = 0; i < 30000; i++) {
			String s = i < cases.length ? cases[i][0] : randomFieldIntStr();
			String t = i < cases.length ? cases[i][1] : randomFieldIntStr();
			TestArray arr = new TestArray(s, t, Int256Math.FIELD_SUBTRACT_TEMP_WORDS);
			BigInteger a = toBigInt(s);
			BigInteger b = toBigInt(t);
			BigInteger c = a.subtract(b).mod(FIELD_MODULUS);
			Int256Math.fieldSubtract(arr.val, arr.xOff, arr.yOff, arr.zOff, arr.tempOff);
			assertEqualsBigInt256(c, arr.val, arr.zOff);
			arr.checkClobber();
		}
	}
	
	
	@Test public void testFieldMultiply2() {
		String[] cases = {
			"0000000000000000000000000000000000000000000000000000000000000000",
			"0000000000000000000000000000000000000000000000000000000000000001",
			"0000000000000000000000000000000000000000000000000000000080000000",
			"00000000000000000000000000000000000000000000000000000000FFFFFFFF",
			"000ABCDEF0000000000000000000000000000000000000000000000000000000",
			"8000000000000000000000000000000000000000000000000000000000000000",
			"FFFF000000000000000000000000000000000000000000000000000000000000",
			"7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFE17",
			"7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFE18",
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2E",
			"34C8B477C0E20991A17F295A49F4F671EC4126CEE5A07EDEF85BA9CE12167127",
		};
		for (int i = 0; i < 30000; i++) {
			String s = i < cases.length ? cases[i] : randomFieldIntStr();
			TestArray arr = new TestArray(s, null, Int256Math.FIELD_MULTIPLY2_TEMP_WORDS);
			BigInteger a = toBigInt(s);
			BigInteger b = a.shiftLeft(1).mod(FIELD_MODULUS);
			Int256Math.fieldMultiply2(arr.val, arr.xOff, arr.zOff, arr.tempOff);
			assertEqualsBigInt256(b, arr.val, arr.zOff);
			arr.checkClobber();
		}
	}
	
	
	@Test public void testFieldSquare() {
		String[] cases = {
			"0000000000000000000000000000000000000000000000000000000000000000",
			"0000000000000000000000000000000000000000000000000000000000000001",
			"000000000000000000000000000000000000000000000000000000000000000D",
			"0000000000000000000000000000000000000000000000000000000000010000",
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2C",
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2D",
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2E",
			"0000000000400000000100000004000000011040000000200400000000401002",
			"0000000000000000000002100000000000000001000000100000000000000800",
			"0002020040000200000000000000100000000410000000000000000000000000",
			"1000000008008400000000000000000000200000000000000020000000000000",
			"0018484A883C83014F000060A81004032E4280B134E118202CD6002001020008",
			"10090024008008C8002010800015A0113822109912105300048C0280A2B00C11",
			"0C49400420000200C031484216240A804408000240600446C122812001008040",
			"002A8023B00101000460200300E05490104240A14300008041C0210800240102",
			"D44459EC5669C56C03485BE9C803519EEB977F8A6000F792D0916B43031EEC1C",
			"03FAEC56081E36092A72FA87B01132C946A60307CD8BF2032725423D44894689",
			"AB013B2A27380172D641B9E05471E91EDB00D962610E018334B19E7FA1FFE0A9",
			"32F2943DA6EC0CAD5E69C0C9B1437A5EA3B9A9FFA14E92C0F6B51C25FD400661",
			"B7AAF40F663FB643BA2C24EB0BA4B4E50D159041C5F8317EA452F6851BDE308B",
			"E83608ECE352FC369836FB19B5EBE6B565254BF4C644B71EA2CD4227C30FFA8E",
			"82914A20F06D7B6B14BB3A4E133C9502ADB2D82CFE99010507425FD69870C31A",
			"F8F2C1D5A0C5005E82CF09331249D8325885D254AF460DEEDEE00DF91FCFEE7B",
			"FFFFFFFFFFEFFFFFFDFFFFFFFFFFFFFFFEFABFFFFFFFFFFDBFFFFEFDFFFFDFFF",
			"7FFFEFFFFFFFFEFFFFFEFFFFFFBFEFFFFFFFBFFFFFF7FFFFFFFF7FFFFFFFFFFF",
			"FFFFFFFEFFF7FFBFFFFFEFEFFFFFFFFFFFFFFFFFFFFFFFFFF5FFFFFFFFF7FFFF",
			"FFFBFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFDFFFFFFFFFF",
		};
		for (int i = 0; i < 30000; i++) {
			String s = i < cases.length ? cases[i] : randomFieldIntStr();
			TestArray arr = new TestArray(s, null, Int256Math.FIELD_SQUARE_TEMP_WORDS);
			BigInteger a = toBigInt(s);
			BigInteger b = a.pow(2).mod(FIELD_MODULUS);
			Int256Math.fieldSquare(arr.val, arr.xOff, arr.zOff, arr.tempOff);
			assertEqualsBigInt256(b, arr.val, arr.zOff);
			arr.checkClobber();
		}
	}
	
	
	@Test public void testFieldMultiply() {
		String[][] cases = {
			{"0000000000000000000000000000000000000000000000000000000000000000", "0000000000000000000000000000000000000000000000000000000000000000"},
			{"0000000000000000000000000000000000000000000000000000000000000001", "0000000000000000000000000000000000000000000000000000000000000001"},
			{"0000000000000000000000000000000000000000000000000000000000000002", "0000000000000000000000000000000000000000000000000000000000000004"},
			{"000000000000000000000000000000000000000000000000000000000000BB81", "0000000000000000000000000000000000000000000000000000000000002375"},
			{"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2E", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2E"},
			{"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2C", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC25"},
			{"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE00000000", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE00000000"},
			{"ABC928448F874620BDB2D01F4D797EED5788CC2475334002E16E6BCC12DCF419", "D661B81BED420F5B5DD8027D1486C7D27C85E6BDB0405EC07849CFD1A7EE526C"},
			{"3720E6127667A3DE448044EE8DECD7C96F345CDA261682A4386719A387C37ED5", "F8E32435123472D4949BF98C22A87A374923A3B06B289EF15E93F0940AAB3650"},
			{"47E3D45C7F5A64DE0D4913911D541BBC0DF640C0920A4FB42FC6ED5ACE413D51", "E8BD16CB61DF4B53B66A35140377314B7EA9CB1099D7E1F05FC50FC49D0EDDF2"},
			{"C3AACF7136F758A89979DD75CF45B6AF07486D43D1B5767C269210EE61C904F4", "EA31DEF20213B863699C0F370265E53F8FDCA440CC0690E6D3672928BEA51DC4"},
			{"290C735EECFEDD247D92D5DB8CED26626F8196E2A6F0D7282D97354484134110", "E0BBDEF09C2E071D94F71FA78DDE9E5E785C3AF99C53DDF63F29409752488C53"},
			{"926E48EB3B5E7017D3C4BDF3FCD34938BB469782991EB4D8AFA8FDC192091058", "D61C4475D5E43CE7F7F922F4BA9E1D52A94602CFBF73836EC20ECF748D7A2AB2"},
			{"71D40203AEC9CC1A35CF06B490A742208729B7A000CA8DD32E72A7813D98AB44", "A59F39FC19046E62CB85F0654133E0323C5A21020D5F26B1A52A41626689E330"},
			{"5CFBD891A5591D3D2B48EAFA4CF890804D8B4AF83D2CA1B1BF0D8E723575C657", "CED7A3AC8DF01F9E1FB478DDDE3DB6B20FBC61709798525099C6CE4CBE21E78E"},
			{"0000000000000000000000100000000004000000008000000000000000000000", "0400020000000000000400000040000000000000000000000000000000000000"},
			{"0000000000000000800000000000000200000000000000000000020000000000", "0000000000000004000000000000000000000000000000000000000000100000"},
			{"0000000004000008000000000000000000000000100000000000000000000000", "0000000000000000000001000000000000000000000000000000000000000000"},
			{"0000000000000000000000002480000000000800000000000000008000000001", "0000000000000000000000000000000000000000000000000000000010000000"},
			{"0000000000010100000080000000000000000000000000000000000000000000", "0000000000800004002000000000000000000000000000000000000000000000"},
			{"0000000000001900004000000000000000000000000000000000000000000000", "0000000004000000002000000000000000000020010000000000000000010000"},
			{"0000000020000000000000000800020000000004004000000000000000000000", "0000000000000000000000000000000000000000000000000000000000000000"},
			{"0000000000000000000000000000000000000008000000000000500010000000", "0000020000000000000000000000020000000000000000000000000002000080"},
			{"000000080080200822000024800000809021080140000120400020000402001A", "0800002000000081000000002080080008000011408040060000008002001818"},
			{"0000000080800584081000825000448240002002000000220000000000000010", "1000004400000000000000004000020240A08200080512000080080400090400"},
			{"0000000000002010401800001030604101000010000000008408001000500000", "0020002000400040000000020210408008800025000080100004004001000000"},
			{"0009000200002008000C24200400000000040402000000004400200000000000", "00000000000820008001004400800A040002000000000004080C0000002C0010"},
			{"0800002000010240400000000004010281020000002C00200000840280000402", "0010000800000400000064000200002481000010080134001200000000001000"},
			{"0041004100000A00000480060000001000405000008000020080014001200100", "0000008000021200040006000000000220000000040200000080180082042500"},
			{"0000000442001000102010400000000000024100010000000222000008000000", "4001000000000400000000020000088000200000004000000000008100208000"},
			{"0040050240000002000010009004000110000000080880800804040001000000", "8000001400020200000000080000800080000000008008104000000280001000"},
		};
		for (int i = 0; i < 30000; i++) {
			String s = i < cases.length ? cases[i][0] : randomFieldIntStr();
			String t = i < cases.length ? cases[i][1] : randomFieldIntStr();
			TestArray arr = new TestArray(s, t, Int256Math.FIELD_MULTIPLY_TEMP_WORDS);
			BigInteger a = toBigInt(s);
			BigInteger b = toBigInt(t);
			BigInteger c = a.multiply(b).mod(FIELD_MODULUS);
			Int256Math.fieldMultiply(arr.val, arr.xOff, arr.yOff, arr.zOff, arr.tempOff);
			assertEqualsBigInt256(c, arr.val, arr.zOff);
			arr.checkClobber();
		}
	}
	
	
	@Test public void testReciprocalForField() {
		String modStr = String.format("%064x", FIELD_MODULUS);
		
		// Special case for zero
		{
			TestArray arr = new TestArray("0000000000000000000000000000000000000000000000000000000000000000", modStr, Int256Math.RECIPROCAL_TEMP_WORDS);
			Int256Math.reciprocal(arr.val, arr.xOff, arr.yOff, arr.zOff, arr.tempOff);
			assertEqualsBigInt256(BigInteger.ZERO, arr.val, arr.zOff);
			arr.checkClobber();
		}
		
		// General and random cases
		String[] cases = {
			"0000000000000000000000000000000000000000000000000000000000000001",
			"000000000000000000000000000000000000000000000000000000000000000D",
			"0000000000000000000000000000000000000000000000000000000000010000",
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2C",
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2D",
			"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2E",
			"0000000000400000000100000004000000011040000000200400000000401002",
			"0000000000000000000002100000000000000001000000100000000000000800",
			"0002020040000200000000000000100000000410000000000000000000000000",
			"1000000008008400000000000000000000200000000000000020000000000000",
			"0018484A883C83014F000060A81004032E4280B134E118202CD6002001020008",
			"10090024008008C8002010800015A0113822109912105300048C0280A2B00C11",
			"0C49400420000200C031484216240A804408000240600446C122812001008040",
			"002A8023B00101000460200300E05490104240A14300008041C0210800240102",
			"D44459EC5669C56C03485BE9C803519EEB977F8A6000F792D0916B43031EEC1C",
			"03FAEC56081E36092A72FA87B01132C946A60307CD8BF2032725423D44894689",
			"AB013B2A27380172D641B9E05471E91EDB00D962610E018334B19E7FA1FFE0A9",
			"32F2943DA6EC0CAD5E69C0C9B1437A5EA3B9A9FFA14E92C0F6B51C25FD400661",
			"B7AAF40F663FB643BA2C24EB0BA4B4E50D159041C5F8317EA452F6851BDE308B",
			"E83608ECE352FC369836FB19B5EBE6B565254BF4C644B71EA2CD4227C30FFA8E",
			"82914A20F06D7B6B14BB3A4E133C9502ADB2D82CFE99010507425FD69870C31A",
			"F8F2C1D5A0C5005E82CF09331249D8325885D254AF460DEEDEE00DF91FCFEE7B",
			"FFFFFFFFFFEFFFFFFDFFFFFFFFFFFFFFFEFABFFFFFFFFFFDBFFFFEFDFFFFDFFF",
			"7FFFEFFFFFFFFEFFFFFEFFFFFFBFEFFFFFFFBFFFFFF7FFFFFFFF7FFFFFFFFFFF",
			"FFFFFFFEFFF7FFBFFFFFEFEFFFFFFFFFFFFFFFFFFFFFFFFFF5FFFFFFFFF7FFFF",
			"FFFBFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFDFFFFFFFFFF",
		};
		for (int i = 0; i < 30000; i++) {
			String s = i < cases.length ? cases[i] : randomFieldIntStr();
			TestArray arr = new TestArray(s, modStr, Int256Math.RECIPROCAL_TEMP_WORDS);
			BigInteger a = toBigInt(s);
			if (a.signum() == 0)
				continue;
			BigInteger b = a.modInverse(FIELD_MODULUS);
			Int256Math.reciprocal(arr.val, arr.xOff, arr.yOff, arr.zOff, arr.tempOff);
			assertEqualsBigInt256(b, arr.val, arr.zOff);
			arr.checkClobber();
		}
	}
	
	
	/*---- Helper definitions ----*/
	
	private static String randomInt256Str() {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < 8; i++) {
			int word;
			double type = rand.nextDouble();
			if (type < 0.2)
				word = rand.nextInt();
			else {
				word = rand.nextInt(10);
				if (type < 0.6)
					word = ~word;
			}
			sb.append(String.format("%08x", word));
		}
		return sb.toString();
	}
	
	
	private static String randomFieldIntStr() {
		while (true) {
			String s = randomInt256Str();
			if (toBigInt(s).compareTo(FIELD_MODULUS) < 0)
				return s;
		}
	}
	
	
	private static void assertEqualsBigInt256(BigInteger num, int[] val, int off) {
		for (int i = 0; i < 8; i++)
			assertEquals(num.shiftRight(i * 32).intValue(), val[off + i]);
	}
	
	
	private static BigInteger toBigInt(String s) {
		return new BigInteger(s, 16);
	}
	
	
	private static final BigInteger FIELD_MODULUS = new BigInteger("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F", 16);
	
	
	private static Random rand = new Random();
	
	
	
	// A single array of int32 words with random offsets to three aligned, disjoint 8-word substrings.
	private static final class TestArray {
		
		public final int[] val;  // Reference is immutable, but elements are allowed to change
		public final int xOff;
		public final int yOff;
		public final int zOff;
		public final int tempOff;
		private final int tempLen;
		private final int[] originalVal;
		
		
		public TestArray(String xStr, String yStr, int tempLen) {
			this.tempLen = tempLen;
			int valLen = 24 + tempLen + rand.nextInt(64);
			val = new int[valLen];
			for (int i = 0; i < val.length; i++)
				val[i] = rand.nextInt();
			
			int numSlots = val.length / 8;
			while (true) {
				int x = rand.nextInt(numSlots) * 8;
				int y = rand.nextInt(numSlots) * 8;
				int z = rand.nextInt(numSlots) * 8;
				int t = rand.nextInt(numSlots - tempLen / 8 + 1) * 8;
				if ((xStr == null || yStr == null || xStr.equals(yStr) || x != y) && (x < t || x >= t + tempLen) && (y < t || y >= t + tempLen) && (z < t || z >= t + tempLen)) {
					xOff = x;
					yOff = y;
					zOff = z;
					tempOff = t;
					break;
				}
			}
			if (xStr != null) Int256Math.hexToUint(xStr, val, xOff);
			if (yStr != null) Int256Math.hexToUint(yStr, val, yOff);
			originalVal = val.clone();
		}
		
		
		public void checkClobber() {
			for (int i = 0; i < val.length; i++)
				assertTrue(originalVal[i] == val[i] || i >= tempOff && i < tempOff + tempLen || i >= zOff && i < zOff + 8);
		}
		
	}
	
}
